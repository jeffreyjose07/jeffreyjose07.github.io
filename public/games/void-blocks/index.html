<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>VOID BLOCKS - Neural Network Security Protocol</title>
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
  <link rel="shortcut icon" href="/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Outfit:wght@400;500;600;700;800&display=swap"
    rel="stylesheet">
  <style>
    :root {
      /* Default Light Theme Variables */
      --background: #ffffff;
      --foreground: #0f172a;
      --primary: #7c3aed;
      --primary-foreground: #f8fafc;
      --primary-glow: #a78bfa;
      --secondary: #f1f5f9;
      --muted: #f1f5f9;
      --muted-foreground: #64748b;
      --border: #e2e8f0;

      /* Premium Game Colors - Light Mode */
      --game-bg: #ffffff;
      --game-panel: rgba(255, 255, 255, 0.5);
      --game-border: #e2e8f0;
      --game-text: #0f172a;
      --game-accent: #7c3aed;

      --terminal: #7c3aed;
      --data: #8b5cf6;
      --virus: #db2777;
      --warning: #f59e0b;
      --special: #0ea5e9;

      --font-sans: 'Inter', sans-serif;
      --font-heading: 'Outfit', sans-serif;
    }

    /* Dark Theme Override */
    html.dark {
      --background: #09090b;
      --foreground: #f8fafc;
      --primary: #a78bfa;
      --primary-foreground: #09090b;
      --primary-glow: #a78bfa;
      --secondary: #1e1e24;
      --muted: #1e1e24;
      --muted-foreground: #94a3b8;
      --border: #27272a;

      /* Premium Game Colors - Dark Mode (Cyberpunk/Neon) */
      --game-bg: #09090b;
      --game-panel: rgba(24, 24, 27, 0.6);
      --game-border: #27272a;
      --game-text: #f8fafc;
      --game-accent: #a78bfa;

      --terminal: #8b5cf6;
      --data: #a78bfa;
      --virus: #f472b6;
      --warning: #fbbf24;
      --special: #38bdf8;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      font-family: var(--font-sans);
      background: var(--background);
      color: var(--foreground);
      overflow-x: hidden;
      overflow-y: auto;
      background-image:
        radial-gradient(at 40% 20%, rgba(124, 58, 237, 0.1) 0px, transparent 50%),
        radial-gradient(at 80% 0%, rgba(59, 130, 246, 0.1) 0px, transparent 50%);
    }

    /* Header */
    .site-header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      z-index: 100;
      transition: all 0.3s ease;
      background: transparent;
      border-bottom: 1px solid transparent;
      padding: 0;
      max-width: none;
      transform: none;
    }

    .site-header.scrolled {
      background: rgba(9, 9, 11, 0.8);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .header-inner {
      max-width: 1400px;
      margin: 0 auto;
      padding: 1rem 2rem;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
    }

    .site-logo {
      font-family: var(--font-heading);
      font-weight: 700;
      font-size: 1.5rem;
      text-decoration: none;
      color: var(--foreground);
      letter-spacing: -0.02em;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      justify-self: start;
    }

    .text-gradient-premium {
      background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      color: transparent;
      display: inline-block;
    }

    .site-nav {
      display: flex;
      align-items: center;
      gap: 2rem;
      justify-self: center;
    }

    .nav-link {
      color: var(--muted-foreground);
      text-decoration: none;
      font-weight: 500;
      transition: color 0.2s;
      font-size: 0.95rem;
    }

    .nav-link:hover,
    .nav-link.active {
      color: var(--foreground);
    }

    .nav-divider {
      width: 1px;
      height: 24px;
      background: rgba(255, 255, 255, 0.1);
    }

    .container {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      gap: 20px;
      padding-top: 80px;
      padding-bottom: 20px;
    }

    .game-area {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }

    canvas {
      background: var(--game-bg);
      border: 2px solid var(--game-border);
      border-radius: 16px;
      box-shadow: 0 0 40px rgba(124, 58, 237, 0.15);
      transition: box-shadow 0.3s ease;
    }

    .panels {
      width: 280px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .panel {
      background: var(--game-panel);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border: 1px solid var(--game-border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }

    .panel-title {
      color: var(--primary);
      font-family: var(--font-heading);
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .title-panel .panel-title {
      color: var(--foreground);
      font-size: 18px;
      text-align: center;
      margin-bottom: 5px;
      background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .subtitle {
      color: var(--primary-glow);
      font-size: 11px;
      text-align: center;
      opacity: 0.9;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin: 8px 0;
      font-size: 13px;
    }

    .stat-label {
      color: var(--muted-foreground);
    }

    .stat-value {
      color: var(--foreground);
      font-weight: bold;
    }

    .score-value {
      color: var(--game-accent);
      font-size: 24px;
      font-weight: 800;
      font-family: var(--font-heading);
      text-shadow: 0 0 15px rgba(124, 58, 237, 0.3);
    }

    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
      animation: pulse 2s infinite;
    }

    .status-stable {
      background: var(--terminal);
    }

    .status-unstable {
      background: var(--warning);
    }

    .status-critical {
      background: var(--virus);
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    .controls {
      font-size: 12px;
      line-height: 1.6;
    }

    .control-row {
      margin: 4px 0;
      color: var(--muted-foreground);
    }

    .key {
      color: var(--primary);
      font-weight: bold;
      background: rgba(255, 255, 255, 0.05);
      padding: 2px 6px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .legend {
      margin-top: 10px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      margin: 4px 0;
      font-size: 12px;
      color: var(--muted-foreground);
    }

    .legend-color {
      width: 12px;
      height: 12px;
      margin-right: 8px;
      border-radius: 4px;
    }

    .terminal {
      background: var(--terminal);
    }

    .data {
      background: var(--data);
    }

    .virus {
      background: var(--virus);
    }

    .warning {
      background: var(--warning);
    }

    .special {
      background: var(--special);
    }

    .game-over,
    .paused {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(9, 9, 11, 0.9);
      backdrop-filter: blur(8px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .overlay-text {
      color: var(--virus);
      font-family: var(--font-heading);
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .overlay-subtitle {
      color: var(--primary-glow);
      font-size: 14px;
      margin-bottom: 20px;
    }

    .restart-hint {
      color: var(--foreground);
      font-size: 12px;
      animation: pulse 2s infinite;
    }

    .hidden {
      display: none !important;
    }

    .start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--background);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      background-image:
        radial-gradient(at 40% 20%, rgba(124, 58, 237, 0.1) 0px, transparent 50%),
        radial-gradient(at 80% 0%, rgba(59, 130, 246, 0.1) 0px, transparent 50%);
    }

    .start-content {
      max-width: 800px;
      max-height: 90vh;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.03);
      backdrop-filter: blur(16px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 40px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
    }

    .start-header {
      text-align: center;
      margin-bottom: 30px;
    }

    .start-title {
      color: var(--foreground);
      font-family: var(--font-heading);
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .start-subtitle {
      color: var(--primary-glow);
      font-size: 14px;
      opacity: 0.9;
    }

    .start-sections {
      display: grid;
      gap: 25px;
      margin-bottom: 30px;
    }

    .start-section {
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 20px;
    }

    .section-title {
      color: var(--primary);
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .section-content {
      color: var(--muted-foreground);
      font-size: 13px;
      line-height: 1.5;
    }

    .fragment-item {
      display: flex;
      align-items: center;
      margin: 10px 0;
    }

    .fragment-preview {
      width: 16px;
      height: 16px;
      margin-right: 12px;
      border-radius: 4px;
      box-shadow: 0 0 4px currentColor;
    }

    .fragment-desc {
      flex: 1;
    }

    .control-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .control-item {
      display: flex;
      align-items: center;
    }

    .control-key {
      color: var(--primary);
      font-weight: bold;
      min-width: 60px;
      margin-right: 10px;
    }

    .warning-item {
      margin: 8px 0;
      color: var(--muted-foreground);
    }

    .start-footer {
      text-align: center;
    }

    .start-button {
      background: linear-gradient(135deg, var(--primary), #6366f1);
      border: none;
      border-radius: 12px;
      padding: 15px 40px;
      color: #fff;
      font-family: inherit;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 10px 20px -5px rgba(124, 58, 237, 0.5);
    }

    .start-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 15px 30px -5px rgba(124, 58, 237, 0.6);
    }

    .start-button:active {
      transform: translateY(0);
    }

    .button-text {
      display: block;
      margin-bottom: 5px;
    }

    .button-hint {
      display: block;
      font-size: 10px;
      opacity: 0.8;
      font-weight: normal;
    }

    .version {
      position: fixed;
      bottom: 10px;
      right: 10px;
      color: rgba(255, 255, 255, 0.1);
      font-size: 10px;
    }

    /* Mobile Touch Controls - Hidden by default, shown only when game active */
    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(9, 9, 11, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      padding: 15px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      z-index: 1000;
    }

    /* Hide mobile controls when start screen is visible */
    .start-screen:not(.hidden)~.mobile-controls,
    body:has(.start-screen:not(.hidden)) .mobile-controls {
      display: none !important;
    }

    .mobile-row {
      display: flex;
      gap: 10px;
      margin: 8px 0;
      justify-content: center;
    }

    .mobile-btn {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--foreground);
      font-family: inherit;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.15s ease;
      border-radius: 12px;
      min-height: 45px;
      min-width: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .action-btn {
      border-color: var(--primary);
      color: var(--primary);
    }

    .move-btn {
      border-color: var(--muted);
      color: var(--muted);
      font-size: 20px;
    }

    .drop-btn {
      border-color: var(--warning);
      color: var(--warning);
      font-size: 12px;
      min-width: 120px;
    }

    .mobile-btn:active {
      background: rgba(124, 58, 237, 0.2);
      transform: scale(0.95);
      box-shadow: 0 0 10px currentColor;
    }

    .action-btn:active {
      background: rgba(124, 58, 237, 0.2);
    }

    .drop-btn:active {
      background: rgba(251, 191, 36, 0.2);
    }

    /* Mobile Responsive Design - Game-First Approach */
    @media (max-width: 768px) {
      body {
        padding: 0;
        overflow-x: hidden;
        overflow-y: auto;
      }

      .site-header {
        display: none;
      }

      .container {
        flex-direction: column;
        gap: 8px;
        padding: 8px 8px 160px 8px;
        /* Extra bottom padding for fixed controls */
        height: auto;
        min-height: 100vh;
        justify-content: flex-start;
        padding-top: 10px;
        /* Less top padding on mobile, no navbar */
      }

      .game-area {
        flex-direction: column;
        align-items: center;
        gap: 8px;
        width: 100%;
      }

      canvas {
        max-width: 100%;
        height: auto;
      }

      /* Optimized game canvas for mobile - smaller to fit with controls */
      #gameCanvas {
        width: 150px !important;
        height: 300px !important;
        margin: 0 auto;
        display: block;
      }

      /* Compact panels - only show essential info */
      .panels {
        width: 100%;
        max-width: 100%;
        display: flex;
        flex-direction: column;
        gap: 6px;
        order: -1;
        /* Move panels above canvas */
        margin-bottom: 10px;
      }

      .title-panel {
        padding: 4px 8px;
      }

      .title-panel .panel-title {
        font-size: 11px;
        margin-bottom: 2px;
      }

      .title-panel .subtitle {
        font-size: 8px;
      }

      /* Combine stats into one compact panel */
      .panel {
        padding: 4px 6px;
        font-size: 9px;
      }

      .panel-title {
        font-size: 9px;
        margin-bottom: 3px;
      }

      .stat-row {
        margin: 2px 0;
        font-size: 9px;
      }

      .stat-value {
        font-size: 10px;
      }

      .score-value {
        font-size: 12px;
      }

      #nextCanvas {
        width: 80px;
        height: 50px;
      }

      /* Optimized mobile controls - prominently visible without scrolling */
      .mobile-controls {
        display: block;
        position: fixed;
        bottom: max(80px, calc(env(safe-area-inset-bottom, 0px) + 80px));
        /* High enough to always see */
        left: 50%;
        transform: translateX(-50%);
        padding: 6px;
        background: rgba(9, 9, 11, 0.98);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        z-index: 10000;
        max-width: 85vw;
      }

      .mobile-row {
        gap: 4px;
        margin: 2px 0;
      }

      .mobile-btn {
        min-height: 40px;
        min-width: 45px;
        font-size: 13px;
        padding: 6px;
      }

      .drop-btn {
        min-width: 95px;
        font-size: 10px;
        padding: 6px 10px;
      }

      .start-content {
        padding: 15px;
        max-width: 95vw;
        max-height: 85vh;
      }

      .start-title {
        font-size: 16px;
      }

      .section-title {
        font-size: 13px;
      }

      .section-content {
        font-size: 11px;
      }

      .version {
        bottom: 200px;
        /* Well above mobile controls */
        font-size: 8px;
        opacity: 0.5;
        /* Less prominent */
      }

      /* Hide non-essential panels on mobile */
      #controlsPanel,
      .panel:not(.title-panel):nth-child(n+4) {
        display: none;
      }
    }

    @media (max-width: 480px) {
      .container {
        padding: 5px;
        gap: 5px;
      }

      #gameCanvas {
        width: 140px !important;
        height: 280px !important;
      }

      .title-panel .panel-title {
        font-size: 10px;
      }

      .title-panel .subtitle {
        font-size: 7px;
      }

      .panel {
        padding: 3px 5px;
      }

      .mobile-controls {
        bottom: max(70px, calc(env(safe-area-inset-bottom, 0px) + 70px));
        padding: 5px;
        max-width: 90vw;
      }

      .mobile-row {
        gap: 3px;
        margin: 2px 0;
      }

      .mobile-btn {
        min-height: 36px;
        min-width: 42px;
        font-size: 12px;
        padding: 5px;
      }

      .drop-btn {
        min-width: 85px;
        font-size: 9px;
        padding: 5px 8px;
      }

      .version {
        bottom: 180px;
      }

      #nextCanvas {
        width: 60px;
        height: 40px;
      }
    }

    /* Embedded Mode (Iframe) */
    body.embedded .site-header {
      display: none !important;
    }

    body.embedded .container {
      padding-top: 20px;
    }
  </style>
</head>

<body>
  <header class="site-header" id="siteHeader">
    <div class="header-inner">
      <a href="/" class="site-logo">
        <img src="/logo.svg" alt="JJ" width="32" height="32">
        <span>Jeffrey<span style="color: var(--primary)">.</span><span class="text-gradient-premium">Jose</span></span>
      </a>

      <nav class="site-nav">
        <a href="/#hero" class="nav-link">Home</a>
        <a href="/#projects" class="nav-link">Projects</a>
        <a href="/#skills" class="nav-link">Skills</a>
        <a href="/#experience" class="nav-link">Experience</a>
        <a href="/#education" class="nav-link">Education</a>
        <a href="/#contact" class="nav-link">Contact</a>
        <div class="nav-divider"></div>
        <a href="/blog/" class="nav-link">Blog</a>
        <a href="/games/void-blocks/" class="nav-link active">Void Blocks</a>
      </nav>

      <div style="display: flex; justify-content: flex-end; justify-self: end;">
        <button id="themeToggle" class="nav-link"
          style="background: none; border: none; cursor: pointer; color: inherit;">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"
            class="lucide lucide-moon">
            <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" />
          </svg>
        </button>
      </div>


    </div>
  </header>

  <script>
    // Header Scroll Effect
    window.addEventListener('scroll', () => {
      const header = document.getElementById('siteHeader');
      if (window.scrollY > 20) {
        header.classList.add('scrolled');
      } else {
        header.classList.remove('scrolled');
      }
    });

    // Theme Toggle Logic
    const themeToggle = document.getElementById('themeToggle');
    const htmlElement = document.documentElement;

    // Check for saved theme or system preference
    const savedTheme = localStorage.getItem('theme');
    const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    let currentTheme = savedTheme || systemTheme;

    // Function to update theme UI
    const updateThemeUI = (theme) => {
      if (theme === 'dark') {
        htmlElement.classList.add('dark');
        themeToggle.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" /></svg>';
      } else {
        htmlElement.classList.remove('dark');
        themeToggle.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sun"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41-1.41"/><path d="m19.07 4.93-1.41-1.41"/></svg>';
      }
    };

    // Initialize theme
    updateThemeUI(currentTheme);

    // Toggle handler
    themeToggle.addEventListener('click', () => {
      currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
      localStorage.setItem('theme', currentTheme);
      updateThemeUI(currentTheme);
    });

    // Check if embedded in iframe
    if (window.self !== window.top) {
      document.body.classList.add('embedded');
    }
  </script>
  <div class="container">
    <div class="game-area">
      <canvas id="gameCanvas" width="300" height="600"></canvas>

      <div class="panels">
        <div class="panel title-panel">
          <div class="panel-title">VOID BLOCKS</div>
          <div class="subtitle">Neural Network Security Protocol v2.0</div>
        </div>

        <div class="panel">
          <div class="panel-title">System Status</div>
          <div class="stat-row">
            <span class="stat-label">SCORE</span>
            <span class="stat-value score-value" id="score">0</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">LEVEL</span>
            <span class="stat-value" id="level">1</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">LINES</span>
            <span class="stat-value" id="lines">0</span>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Network Status</div>
          <div class="stat-row">
            <span class="stat-label">CONNECTION</span>
            <span class="stat-value" id="connection">
              <span class="status-indicator status-stable"></span>STABLE
            </span>
          </div>
          <div class="stat-row">
            <span class="stat-label">INTEGRITY</span>
            <span class="stat-value" id="integrity">100%</span>
          </div>
          <div class="stat-row">
            <span class="stat-label">CORRUPTION</span>
            <span class="stat-value" id="corruption">0%</span>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Next Fragment</div>
          <canvas id="nextCanvas" width="120" height="80"></canvas>
        </div>

        <div class="panel" id="controlsPanel">
          <div class="panel-title">Controls</div>
          <div class="controls">
            <div class="control-row"><span class="key">‚Üê / ‚Üí</span> Move</div>
            <div class="control-row"><span class="key">‚Üì</span> Soft Drop</div>
            <div class="control-row"><span class="key">SPACE</span> Hard Drop</div>
            <div class="control-row"><span class="key">‚Üë / Z / X</span> Rotate</div>
            <div class="control-row"><span class="key">P</span> Pause</div>
            <div class="control-row"><span class="key">R</span> Restart</div>
          </div>

          <div class="legend">
            <div class="panel-title" style="font-size: 12px; margin-bottom: 8px;">Block Types</div>
            <div class="legend-item">
              <div class="legend-color terminal"></div>
              <span>Standard Blocks</span>
            </div>
            <div class="legend-item">
              <div class="legend-color data"></div>
              <span>Data Fragments</span>
            </div>
            <div class="legend-item">
              <div class="legend-color virus"></div>
              <span>Virus Blocks</span>
            </div>
            <div class="legend-item">
              <div class="legend-color warning"></div>
              <span>Power-ups</span>
            </div>
            <div class="legend-item">
              <div class="legend-color special"></div>
              <span>Special Blocks</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Mobile Touch Controls -->
  <div class="mobile-controls" id="mobileControls">
    <div class="mobile-row">
      <button class="mobile-btn action-btn" id="mobileRotate">üîÑ</button>
      <button class="mobile-btn action-btn" id="mobilePause">‚è∏</button>
      <button class="mobile-btn action-btn" id="mobileRestart">üÜÅ</button>
    </div>
    <div class="mobile-row">
      <button class="mobile-btn move-btn" id="mobileLeft">‚Üê</button>
      <button class="mobile-btn move-btn" id="mobileDown">‚Üì</button>
      <button class="mobile-btn move-btn" id="mobileRight">‚Üí</button>
    </div>
    <div class="mobile-row">
      <button class="mobile-btn drop-btn" id="mobileDrop">HARD DROP</button>
    </div>
  </div>

  <div class="game-over hidden" id="gameOverScreen">
    <div class="overlay-text">SYSTEM COMPROMISED</div>
    <div class="overlay-subtitle">Neural network security breached</div>
    <div class="stat-row" style="color: var(--text); margin: 10px 0;">
      Final Score: <span style="color: var(--data);" id="finalScore">0</span>
    </div>
    <div class="restart-hint">Press R to restart security protocol</div>
  </div>

  <div class="paused hidden" id="pausedScreen">
    <div class="overlay-text">SYSTEM PAUSED</div>
    <div class="overlay-subtitle">Security protocol suspended</div>
    <div class="restart-hint" style="margin-bottom: 16px;">Press P or tap ‚èØ to resume</div>
    <div class="panel" style="max-width: 90vw;">
      <div class="panel-title" style="text-align:center;">Controls (Mobile)</div>
      <div class="controls">
        <div class="control-row"><span class="key">‚Üê / ‚Üí</span> Move</div>
        <div class="control-row"><span class="key">‚Üì</span> Soft Drop</div>
        <div class="control-row"><span class="key">SPACE</span> Hard Drop</div>
        <div class="control-row"><span class="key">‚Üë / Z / X</span> Rotate</div>
        <div class="control-row"><span class="key">P</span> Pause</div>
        <div class="control-row"><span class="key">R</span> Restart</div>
      </div>
    </div>
  </div>

  <div class="start-screen" id="startScreen">
    <div class="start-content">
      <div class="start-header">
        <div class="start-title">VOID BLOCKS</div>
        <div class="start-subtitle">Neural Network Security Protocol v2.0</div>
      </div>

      <div class="start-sections">
        <div class="start-section">
          <div class="section-title">üìã Mission Briefing</div>
          <div class="section-content">
            You are a security analyst tasked with preventing system corruption in a virtual reality network. Manipulate
            incoming data fragments to maintain system integrity and prevent virus propagation.
          </div>
        </div>

        <div class="start-section">
          <div class="section-title">üß¨ Fragment Types</div>
          <div class="section-content">
            <div class="fragment-item">
              <div class="fragment-preview terminal"></div>
              <div class="fragment-desc"><strong>Standard Blocks</strong> - Basic green fragments (60%)</div>
            </div>
            <div class="fragment-item">
              <div class="fragment-preview data"></div>
              <div class="fragment-desc"><strong>Data Fragments</strong> - Cyan blocks that slow time when cleared (20%)
              </div>
            </div>
            <div class="fragment-item">
              <div class="fragment-preview virus"></div>
              <div class="fragment-desc"><strong>Virus Blocks</strong> - Red corruption that spreads to adjacent blocks
                (8%)</div>
            </div>
            <div class="fragment-item">
              <div class="fragment-preview warning"></div>
              <div class="fragment-desc"><strong>Power-ups</strong> - Yellow blocks that clear all viruses (7%)</div>
            </div>
            <div class="fragment-item">
              <div class="fragment-preview special"></div>
              <div class="fragment-desc"><strong>Special Blocks</strong> - Magenta fragments with bonus points (5%)
              </div>
            </div>
          </div>
        </div>

        <div class="start-section">
          <div class="section-title">üéÆ Control Interface</div>
          <div class="section-content">
            <div class="control-grid">
              <div class="control-item"><span class="control-key">‚Üê ‚Üí</span> Move fragments</div>
              <div class="control-item"><span class="control-key">‚Üì</span> Soft drop</div>
              <div class="control-item"><span class="control-key">SPACE</span> Hard drop</div>
              <div class="control-item"><span class="control-key">‚Üë/Z/X</span> Rotate fragments</div>
              <div class="control-item"><span class="control-key">P</span> Pause protocol</div>
              <div class="control-item"><span class="control-key">R</span> Restart system</div>
            </div>
          </div>
        </div>

        <div class="start-section">
          <div class="section-title">‚ö†Ô∏è System Warnings</div>
          <div class="section-content">
            <div class="warning-item">‚Ä¢ Virus blocks spread to adjacent fragments every 3 seconds (30% chance)</div>
            <div class="warning-item">‚Ä¢ System corruption increases with each virus block placed</div>
            <div class="warning-item">‚Ä¢ Clear virus blocks to reduce corruption levels</div>
            <div class="warning-item">‚Ä¢ Game over occurs when new fragments cannot be placed</div>
          </div>
        </div>
      </div>

      <div class="start-footer">
        <button class="start-button" id="startButton">
          <span class="button-text">INITIALIZE SECURITY PROTOCOL</span>
          <span class="button-hint">Press ENTER or click to begin</span>
        </button>
      </div>
    </div>
  </div>

  <div class="version">v2.0.0</div>

  <script>
    // VOID BLOCKS - Cyberpunk Tetris Implementation
    (() => {
      const COLS = 10, ROWS = 20, BLOCK_SIZE = 30;

      // Canvas elements and contexts - will be initialized when game starts
      let canvas = null;
      let nextCanvas = null;
      let ctx = null;
      let nextCtx = null;

      // Initialize canvas elements and contexts
      function initializeCanvas() {
        console.log('üñºÔ∏è Initializing canvas elements...');

        canvas = document.getElementById('gameCanvas');
        nextCanvas = document.getElementById('nextCanvas');

        if (!canvas || !nextCanvas) {
          console.error('‚ùå Canvas elements not found:', { canvas: !!canvas, nextCanvas: !!nextCanvas });
          return false;
        }

        ctx = canvas.getContext('2d');
        nextCtx = nextCanvas.getContext('2d');

        if (!ctx || !nextCtx) {
          console.error('‚ùå Canvas contexts not available:', { ctx: !!ctx, nextCtx: !!nextCtx });
          return false;
        }

        console.log('‚úÖ Canvas elements initialized successfully');
        return true;
      }

      // Game colors matching cyberpunk theme
      const COLORS = {
        STANDARD: '#55ff55',    // Terminal green
        DATA: '#55ffff',        // Cyan
        VIRUS: '#ff5555',       // Red
        POWER: '#ffaa55',       // Yellow/Orange
        SPECIAL: '#ff55ff',     // Magenta
        BACKGROUND: '#001122'
      };

      // Tetris shapes
      const SHAPES = {
        I: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
        O: [[1, 1], [1, 1]],
        T: [[0, 1, 0], [1, 1, 1], [0, 0, 0]],
        S: [[0, 1, 1], [1, 1, 0], [0, 0, 0]],
        Z: [[1, 1, 0], [0, 1, 1], [0, 0, 0]],
        J: [[1, 0, 0], [1, 1, 1], [0, 0, 0]],
        L: [[0, 0, 1], [1, 1, 1], [0, 0, 0]]
      };

      const SHAPE_NAMES = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];

      // Block types with weights for random generation
      const BLOCK_TYPES = [
        { name: 'STANDARD', color: COLORS.STANDARD, weight: 60 },
        { name: 'DATA', color: COLORS.DATA, weight: 20 },
        { name: 'VIRUS', color: COLORS.VIRUS, weight: 8 },
        { name: 'POWER', color: COLORS.POWER, weight: 7 },
        { name: 'SPECIAL', color: COLORS.SPECIAL, weight: 5 }
      ];

      // Game state
      let board = createMatrix(ROWS, COLS);
      let virusBoard = createMatrix(ROWS, COLS); // Track virus infections
      let current = null;
      let next = null;
      let score = 0, level = 1, lines = 0;
      let dropTime = 0;
      let dropInterval = 1000;
      let lastTime = 0;
      let gameOver = false;
      let paused = false;
      let corruption = 0;
      let virusSpreadTimer = 0;
      let bag = [];
      let gameStarted = false;

      function createMatrix(rows, cols) {
        return Array.from({ length: rows }, () => Array(cols).fill(0));
      }

      function getRandomBlockType() {
        const totalWeight = BLOCK_TYPES.reduce((sum, type) => sum + type.weight, 0);
        const random = Math.random() * totalWeight;
        let accumulated = 0;

        for (let type of BLOCK_TYPES) {
          accumulated += type.weight;
          if (random <= accumulated) {
            return type;
          }
        }
        return BLOCK_TYPES[0];
      }

      function generateShapeBag() {
        const shuffled = [...SHAPE_NAMES];
        for (let i = shuffled.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
      }

      function createPiece() {
        if (bag.length === 0) {
          bag = generateShapeBag();
        }

        const shapeKey = bag.pop();
        const shape = SHAPES[shapeKey].map(row => [...row]);
        const blockType = getRandomBlockType();

        return {
          shape,
          x: Math.floor((COLS - shape[0].length) / 2),
          y: 0,
          type: blockType
        };
      }

      function rotate(matrix, clockwise = true) {
        const N = matrix.length;
        const rotated = Array.from({ length: N }, () => Array(N).fill(0));

        for (let i = 0; i < N; i++) {
          for (let j = 0; j < N; j++) {
            if (clockwise) {
              rotated[j][N - 1 - i] = matrix[i][j];
            } else {
              rotated[N - 1 - j][i] = matrix[i][j];
            }
          }
        }
        return rotated;
      }

      function isValidMove(piece, dx = 0, dy = 0, newShape = null) {
        const shape = newShape || piece.shape;
        const newX = piece.x + dx;
        const newY = piece.y + dy;

        for (let y = 0; y < shape.length; y++) {
          for (let x = 0; x < shape[y].length; x++) {
            if (shape[y][x]) {
              const boardX = newX + x;
              const boardY = newY + y;

              if (boardX < 0 || boardX >= COLS ||
                boardY >= ROWS ||
                (boardY >= 0 && board[boardY][boardX])) {
                return false;
              }
            }
          }
        }
        return true;
      }

      function placePiece(piece) {
        for (let y = 0; y < piece.shape.length; y++) {
          for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
              const boardX = piece.x + x;
              const boardY = piece.y + y;

              if (boardY >= 0) {
                board[boardY][boardX] = piece.type.color;

                // Mark virus blocks
                if (piece.type.name === 'VIRUS') {
                  virusBoard[boardY][boardX] = 1;
                  corruption = Math.min(100, corruption + 5);
                }

                // Random chance for standard blocks to become virus
                if (piece.type.name === 'STANDARD' && Math.random() < 0.1) {
                  virusBoard[boardY][boardX] = 1;
                  board[boardY][boardX] = COLORS.VIRUS;
                }
              }
            }
          }
        }
      }

      function clearLines() {
        let linesCleared = 0;
        let dataFragmentsCleared = 0;
        let virusBlocksCleared = 0;

        for (let y = ROWS - 1; y >= 0; y--) {
          if (board[y].every(cell => cell !== 0)) {
            // Count special blocks in cleared line
            for (let x = 0; x < COLS; x++) {
              if (board[y][x] === COLORS.DATA) dataFragmentsCleared++;
              if (virusBoard[y][x]) virusBlocksCleared++;
            }

            board.splice(y, 1);
            board.unshift(Array(COLS).fill(0));
            virusBoard.splice(y, 1);
            virusBoard.unshift(Array(COLS).fill(0));
            linesCleared++;
            y++; // Check the same line again
          }
        }

        if (linesCleared > 0) {
          // Scoring system
          const basePoints = [0, 40, 100, 300, 1200];
          let points = (basePoints[linesCleared] || 500) * level;

          // Bonus for data fragments
          if (dataFragmentsCleared > 0) {
            points *= (1 + dataFragmentsCleared * 0.5);
            let isPaused = false;
            let isGameOver = false;
            let isGameActive = false;
            let animationId = null;

            let piece = null;
            let nextPiece = null;

            // Initialize High Score
            highScoreEl.textContent = highScore;

            // Piece Class
            class Piece {
              constructor(shape = null, colorType = null) {
                this.shape = shape || SHAPES[Math.floor(Math.random() * SHAPES.length)];
                this.colorType = colorType || this.getRandomColorType();
                this.x = Math.floor(COLS / 2) - Math.floor(this.shape[0].length / 2);
                this.y = 0;
              }

              getRandomColorType() {
                const rand = Math.random();
                if (rand < 0.6) return 'terminal'; // 60% standard
                if (rand < 0.8) return 'data';     // 20% data
                if (rand < 0.9) return 'warning';  // 10% warning
                if (rand < 0.95) return 'virus';   // 5% virus
                return 'special';                  // 5% special
              }
            }

            // Drawing Functions
            function drawBlock(ctx, x, y, colorType, size = BLOCK_SIZE) {
              const colors = getColors();
              const color = colors[colorType] || colors.terminal;

              ctx.fillStyle = color;
              ctx.fillRect(x * size, y * size, size, size);

              // Inner bevel effect
              ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
              ctx.fillRect(x * size, y * size, size, 4);
              ctx.fillRect(x * size, y * size, 4, size);

              ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
              ctx.fillRect(x * size + size - 4, y * size, 4, size);
              ctx.fillRect(x * size, y * size + size - 4, size, 4);

              // Border
              ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
              ctx.strokeRect(x * size, y * size, size, size);
            }

            function drawBoard() {
              const colors = getColors();

              // Clear canvas
              ctx.fillStyle = colors.bg;
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              // Draw grid (subtle)
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
              ctx.lineWidth = 1;
              for (let i = 0; i <= COLS; i++) {
                ctx.beginPath();
                ctx.moveTo(i * BLOCK_SIZE, 0);
                ctx.lineTo(i * BLOCK_SIZE, canvas.height);
                ctx.stroke();
              }
              for (let i = 0; i <= ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * BLOCK_SIZE);
                ctx.lineTo(canvas.width, i * BLOCK_SIZE);
                ctx.stroke();
              }

              // Draw board blocks
              board.forEach((row, y) => {
                row.forEach((value, x) => {
                  if (value) {
                    drawBlock(ctx, x, y, value);
                  }
                });
              });

              // Draw current piece
              if (piece) {
                piece.shape.forEach((row, y) => {
                  row.forEach((value, x) => {
                    if (value) {
                      drawBlock(ctx, piece.x + x, piece.y + y, piece.colorType);
                    }
                  });
                });
              }
            }

            function drawNextPiece() {
              const colors = getColors();
              nextCtx.fillStyle = colors.bg;
              nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

              if (nextPiece) {
                const offsetX = (nextCanvas.width - nextPiece.shape[0].length * 20) / 2;
                const offsetY = (nextCanvas.height - nextPiece.shape.length * 20) / 2;

                nextPiece.shape.forEach((row, y) => {
                  row.forEach((value, x) => {
                    if (value) {
                      drawBlock(nextCtx, x + offsetX / 20, y + offsetY / 20, nextPiece.colorType, 20);
                    }
                  });
                });
              }
            }

            // Game Logic
            function collide(arena, player) {
              const [m, o] = [player.shape, player];
              for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                  if (m[y][x] !== 0 &&
                    (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
                    return true;
                  }
                }
              }
              return false;
            }

            function merge(arena, player) {
              player.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                  if (value) {
                    arena[y + player.y][x + player.x] = player.colorType;
                  }
                });
              });
            }

            function rotate(matrix) {
              for (let y = 0; y < matrix.length; ++y) {
                for (let x = 0; x < y; ++x) {
                  [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                }
              }
              matrix.forEach(row => row.reverse());
            }

            function playerRotate(dir) {
              const pos = piece.x;
              let offset = 1;
              rotate(piece.shape);
              while (collide(board, piece)) {
                piece.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > piece.shape[0].length) {
                  rotate(piece.shape); // Rotate back
                  rotate(piece.shape);
                  rotate(piece.shape);
                  piece.x = pos;
                  return;
                }
              }
            }

            function playerReset() {
              piece = nextPiece;
              nextPiece = new Piece();
              drawNextPiece();

              if (collide(board, piece)) {
                gameOver();
              }
            }

            function arenaSweep() {
              let rowCount = 0;
              outer: for (let y = board.length - 1; y > 0; --y) {
                for (let x = 0; x < board[y].length; ++x) {
                  if (board[y][x] === 0) {
                    continue outer;
                  }
                }

                const row = board.splice(y, 1)[0];
                board.unshift(row.fill(0));
                ++y;
                rowCount++;
              }

              if (rowCount > 0) {
                // Score calculation
                // 1 line: 100 * level
                // 2 lines: 300 * level
                // 3 lines: 500 * level
                // 4 lines: 800 * level
                const lineScores = [0, 100, 300, 500, 800];
                score += lineScores[rowCount] * level;
                lines += rowCount;
                level = Math.floor(lines / 10) + 1;
                dropInterval = Math.max(100, 1000 - (level - 1) * 100);

                updateStats();
              }
            }

            function updateStats() {
              scoreEl.textContent = score;
              levelEl.textContent = level;
              linesEl.textContent = lines;

              if (score > highScore) {
                highScore = score;
                highScoreEl.textContent = highScore;
                localStorage.setItem('void_blocks_high_score', highScore);
              }

              // Update status indicator
              if (level < 5) {
                statusIndicator.className = 'status-indicator status-stable';
                statusText.textContent = 'SYSTEM STABLE';
                statusText.style.color = 'var(--terminal)';
              } else if (level < 10) {
                statusIndicator.className = 'status-indicator status-unstable';
                statusText.textContent = 'SYSTEM UNSTABLE';
                statusText.style.color = 'var(--warning)';
              } else {
                statusIndicator.className = 'status-indicator status-critical';
                statusText.textContent = 'CRITICAL FAILURE';
                statusText.style.color = 'var(--virus)';
              }
            }

            function playerDrop() {
              piece.y++;
              if (collide(board, piece)) {
                piece.y--;
                merge(board, piece);
                playerReset();
                arenaSweep();
              }
              dropCounter = 0;
            }

            function playerMove(dir) {
              piece.x += dir;
              if (collide(board, piece)) {
                piece.x -= dir;
              }
            }

            function update(time = 0) {
              if (isPaused || isGameOver || !isGameActive) return;

              const deltaTime = time - lastTime;
              lastTime = time;

              dropCounter += deltaTime;
              if (dropCounter > dropInterval) {
                playerDrop();
              }

              drawBoard();
              animationId = requestAnimationFrame(update);
            }

            function startGame() {
              if (!canvas) {
                if (!initializeCanvas()) return;
              }

              // Reset game state
              board = createMatrix(ROWS, COLS);
              virusBoard = createMatrix(ROWS, COLS);
              current = null;
              next = null;
              score = 0;
              level = 1;
              lines = 0;
              corruption = 0;
              dropTime = 0;
              dropInterval = 1000;
              virusSpreadTimer = 0;
              gameOver = false;
              paused = false;
              bag = [];
              gameStarted = true;

              // Hide all overlay screens with error handling
              ['gameOverScreen', 'pausedScreen', 'startScreen'].forEach(screenId => {
                const screen = document.getElementById(screenId);
                if (screen) {
                  screen.classList.add('hidden');
                } else {
                  console.warn(`‚ö†Ô∏è Screen element ${screenId} not found`);
                }
              });

              // Initialize game
              try {
                spawnNext();
                playerReset(); // Spawn first piece
                updateUI();
                lastTime = performance.now();
                requestAnimationFrame(update);
                console.log('‚úÖ Game started successfully');
              } catch (error) {
                console.error('‚ùå Error starting game:', error);
                gameStarted = false;
              }
            }

            function restart() {
              startGame();
            }

            // Initialize DOM event listeners when DOM is ready
            function initializeEventListeners() {
              console.log('üîó Setting up event listeners...');

              // Start screen event listeners with error handling
              const startButton = document.getElementById('startButton');
              console.log('üîç Start button element:', startButton);

              if (startButton) {
                console.log('üìù Adding click listener to start button...');
                startButton.addEventListener('click', () => {
                  console.log('üñ±Ô∏è Start button clicked!');
                  startGame();
                });
                console.log('‚úÖ Click listener added');
              } else {
                console.error('‚ùå Start button not found in DOM');
                return;
              }

              // Input handling
              console.log('‚å®Ô∏è Adding keyboard listener...');
              document.addEventListener('keydown', handleKeyInput);
              console.log('‚úÖ Keyboard listener added');

              // Mobile touch control handlers
              console.log('üì± Adding mobile control listeners...');
              const mobileControls = document.getElementById('mobileControls');
              if (mobileControls) {
                // Movement controls
                document.getElementById('mobileLeft').addEventListener('click', () => {
                  if (current && gameStarted && !gameOver && !paused && isValidMove(current, -1, 0)) {
                    current.x--;
                  }
                });

                document.getElementById('mobileRight').addEventListener('click', () => {
                  if (current && gameStarted && !gameOver && !paused && isValidMove(current, 1, 0)) {
                    current.x++;
                  }
                });

                document.getElementById('mobileDown').addEventListener('click', () => {
                  if (current && gameStarted && !gameOver && !paused && isValidMove(current, 0, 1)) {
                    current.y++;
                    dropTime = 0;
                  }
                });

                // Hard drop
                document.getElementById('mobileDrop').addEventListener('click', () => {
                  if (current && gameStarted && !gameOver && !paused) {
                    while (isValidMove(current, 0, 1)) {
                      current.y++;
                    }
                    dropTime = 0;
                  }
                });

                // Rotation
                document.getElementById('mobileRotate').addEventListener('click', () => {
                  if (current && gameStarted && !gameOver && !paused) {
                    const rotated = rotate(current.shape, true);
                    if (isValidMove(current, 0, 0, rotated)) {
                      current.shape = rotated;
                    }
                  }
                });

                // Pause/Resume
                document.getElementById('mobilePause').addEventListener('click', () => {
                  if (gameStarted && !gameOver) {
                    togglePause();
                  }
                });

                // Restart
                document.getElementById('mobileRestart').addEventListener('click', () => {
                  if (gameStarted) {
                    restart();
                  }
                });

                console.log('‚úÖ Mobile control listeners added');
              }
            }

            function handleKeyInput(e) {
              console.log(`‚å®Ô∏è Key pressed: ${e.key}, gameStarted: ${gameStarted}`);

              // Start screen handling
              if (!gameStarted) {
                if (e.key === 'Enter') {
                  console.log('‚ú® Enter key pressed, starting game...');
                  startGame();
                }
                return;
              }

              if (gameOver) {
                if (e.key.toLowerCase() === 'r') {
                  restart();
                }
                return;
              }

              if (paused && e.key.toLowerCase() !== 'p' && e.key.toLowerCase() !== 'r') {
                return;
              }

              switch (e.key) {
                case 'ArrowLeft':
                  if (current && isValidMove(current, -1, 0)) {
                    current.x--;
                  }
                  break;

                case 'ArrowRight':
                  if (current && isValidMove(current, 1, 0)) {
                    current.x++;
                  }
                  break;

                case 'ArrowDown':
                  if (current && isValidMove(current, 0, 1)) {
                    current.y++;
                    dropTime = 0;
                  }
                  break;

                case ' ': // Hard drop
                  if (current) {
                    while (isValidMove(current, 0, 1)) {
                      current.y++;
                    }
                    placePiece(current);
                    clearLines();
                    spawnNext();
                    dropTime = 0;
                  }
                  e.preventDefault();
                  break;

                case 'ArrowUp':
                case 'z':
                case 'Z':
                  if (current) {
                    const rotated = rotate(current.shape, false);
                    if (isValidMove(current, 0, 0, rotated)) {
                      current.shape = rotated;
                    }
                  }
                  break;

                case 'x':
                case 'X':
                  if (current) {
                    const rotated = rotate(current.shape, true);
                    if (isValidMove(current, 0, 0, rotated)) {
                      current.shape = rotated;
                    }
                  }
                  break;

                case 'p':
                case 'P':
                  togglePause();
                  break;

                case 'r':
                case 'R':
                  restart();
                  break;
              }

              if (e.key === 'ArrowDown' || e.key === ' ') {
                e.preventDefault();
              }
            }

            // Initialize game when DOM is fully loaded
            function initializeGame() {
              console.log('üöÄ Starting game initialization...');

              // Ensure start screen is visible
              const startScreen = document.getElementById('startScreen');
              console.log('üîç Start screen element:', startScreen);

              if (startScreen) {
                startScreen.classList.remove('hidden');
                console.log('‚úÖ Start screen made visible');
              } else {
                console.error('‚ùå Start screen not found!');
                return; // Exit early if critical element missing
              }

              // Initialize event listeners
              console.log('üéØ Initializing event listeners...');
              initializeEventListeners();

              // Initialize UI
              console.log('üñ•Ô∏è Initializing UI...');
              updateUI();

              console.log('‚úÖ Game initialized successfully');
            }

            // Wait for DOM to be ready
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', initializeGame);
            } else {
              initializeGame();
            }
          }) ();
  </script>

  <!-- GoatCounter Analytics -->
  <script data-goatcounter="https://jeffreyjose.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</body>

</html>