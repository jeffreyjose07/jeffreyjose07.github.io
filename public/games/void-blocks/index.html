<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOID BLOCKS - Neural Network Tetris</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000011;
            font-family: 'Monaco', 'Menlo', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #55ff55;
        }
        
        #gameContainer {
            text-align: center;
        }
        
        canvas {
            border: 2px solid #55ffff;
            box-shadow: 0 0 20px #55ffff;
            background: #000008;
        }
        
        #ui {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            max-width: 800px;
            margin: 20px auto;
        }
        
        #gameArea {
            flex: 1;
            text-align: center;
        }
        
        #sidebar {
            width: 200px;
            text-align: left;
            padding: 0 20px;
            color: #55ff55;
        }
        
        .panel {
            background: rgba(0, 28, 0, 0.8);
            border: 1px solid #55ff55;
            padding: 15px;
            margin: 10px 0;
            box-shadow: 0 0 10px #55ff55;
        }
        
        .title {
            color: #55ffff;
            font-size: 24px;
            margin-bottom: 10px;
            text-shadow: 0 0 10px #55ffff;
        }
        
        .score {
            color: #55ff55;
            font-size: 18px;
        }
        
        .controls {
            font-size: 12px;
            line-height: 1.6;
        }
        
        .virus-text {
            color: #ff5555;
            text-shadow: 0 0 10px #ff5555;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="title">VOID BLOCKS</div>
        <div style="color: #55ff55; font-size: 14px; margin-bottom: 10px;">NEURAL NETWORK SECURITY PROTOCOL</div>
        <div style="color: #55ffff; font-size: 12px; margin-bottom: 20px; line-height: 1.4;">
            &gt; OBJECTIVE: Prevent data corruption by organizing incoming data blocks<br>
            &gt; SYSTEM STATUS: Active blocks must be eliminated before buffer overflow<br>
            &gt; WARNING: System integrity decreases with each security level breach
        </div>
        
        <div id="ui">
            <div id="sidebar">
                <div class="panel">
                    <div style="color: #55ffff;">SYSTEM STATUS</div>
                    <div>SCORE: <span id="score" class="score">0</span></div>
                    <div>LEVEL: <span id="level" class="score">1</span></div>
                    <div>LINES: <span id="lines" class="score">0</span></div>
                </div>
                
                <div class="panel">
                    <div style="color: #55ffff;">NETWORK STATUS</div>
                    <div>CONNECTION: <span id="connection">STABLE</span></div>
                    <div>FIREWALL: <span id="firewall">ACTIVE</span></div>
                    <div>INTEGRITY: <span id="integrity">100%</span></div>
                </div>
            </div>
            
            <div id="gameArea">
                <canvas id="gameCanvas" width="300" height="600"></canvas>
            </div>
            
            <div id="sidebar">
                <div class="panel">
                    <div style="color: #55ffff;">CONTROLS</div>
                    <div class="controls">
                        <div style="color: #ffff55; font-size: 11px; margin-bottom: 5px;">MOVEMENT:</div>
                        ← / → : Move block<br>
                        ↓ : Soft drop (+1 pt)<br>
                        SPACE : Hard drop<br>
                        <div style="color: #ffff55; font-size: 11px; margin: 5px 0;">ROTATION:</div>
                        Z : Rotate left<br>
                        X : Rotate right<br>
                        <div style="color: #ffff55; font-size: 11px; margin: 5px 0;">SYSTEM:</div>
                        P : Pause/Resume<br>
                        R : Emergency restart
                    </div>
                </div>
                
                <div class="panel">
                    <div style="color: #55ffff;">NEXT BLOCK</div>
                    <canvas id="nextCanvas" width="80" height="80"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game constants
        const COLS = 10, ROWS = 20, BLOCK = 30;
        
        // Tetromino shapes (matrix forms)
        const SHAPES = {
            I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
            J: [[1,0,0],[1,1,1],[0,0,0]],
            L: [[0,0,1],[1,1,1],[0,0,0]],
            O: [[1,1],[1,1]],
            S: [[0,1,1],[1,1,0],[0,0,0]],
            T: [[0,1,0],[1,1,1],[0,0,0]],
            Z: [[1,1,0],[0,1,1],[0,0,0]]
        };
        
        const COLORS = {
            I:'#55ffff', // Cyan
            J:'#8855ff', // Purple  
            L:'#ff8855', // Orange
            O:'#ffff55', // Yellow
            S:'#55ff55', // Green
            T:'#ff55ff', // Magenta
            Z:'#ff5555'  // Red
        };
        
        const BAG = ['I','J','L','O','S','T','Z'];
        
        // Game state
        let canvas, ctx, nextCanvas, nextCtx;
        let board = createMatrix(ROWS, COLS);
        let current = null;
        let next = null;
        let dropCounter = 0;
        let dropInterval = 800;
        let lastTime = 0;
        let score = 0, level = 1, lines = 0;
        let gameOver = false, paused = false;
        let bag = [];
        
        function createMatrix(r,c){
            const m = new Array(r);
            for(let i=0;i<r;i++) m[i]=new Array(c).fill(0);
            return m;
        }
        
        function randBag(){
            if(bag.length===0) bag = shuffle(BAG.slice());
            return bag.pop();
        }
        
        function shuffle(a){
            for(let i=a.length-1;i>0;i--){
                const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]
            }
            return a;
        }
        
        function newPiece(){
            const id = randBag();
            const shape = SHAPES[id].map(r=>r.slice());
            return {id,shape,y:0,x:Math.floor((COLS-shape[0].length)/2)};
        }
        
        function rotate(matrix, dir){
            // Transpose
            for(let y=0;y<matrix.length;y++){
                for(let x=0;x<y;x++){
                    [matrix[x][y],matrix[y][x]]=[matrix[y][x],matrix[x][y]];
                }
            }
            if(dir>0) matrix.forEach(row=>row.reverse()); else matrix.reverse();
        }
        
        function collide(board, piece){
            const m = piece.shape;
            for(let y=0;y<m.length;y++){
                for(let x=0;x<m[y].length;x++){
                    if(m[y][x] && (board[y+piece.y] && board[y+piece.y][x+piece.x]) !== 0) return true;
                }
            }
            return false;
        }
        
        function merge(board, piece){
            const m = piece.shape;
            for(let y=0;y<m.length;y++){
                for(let x=0;x<m[y].length;x++){
                    if(m[y][x]) board[y+piece.y][x+piece.x] = piece.id;
                }
            }
        }
        
        function clearLines(){
            let rowCount = 0;
            outer: for(let y=ROWS-1;y>=0;y--){
                for(let x=0;x<COLS;x++){
                    if(!board[y][x]){
                        continue outer;
                    }
                }
                // line full
                const row = board.splice(y,1)[0];
                board.unshift(new Array(COLS).fill(0));
                rowCount++;
                y++; // recheck same y after unshift
            }
            if(rowCount>0){
                // scoring: classic tetris style
                const points = [0,40,100,300,1200];
                score += (points[rowCount] || (rowCount*500)) * level;
                lines += rowCount;
                const newLevel = Math.floor(lines/10)+1;
                if(newLevel>level){
                    level = newLevel;
                    dropInterval = Math.max(100, 800 - (level-1)*60);
                }
                updateUI();
            }
        }
        
        function hardDrop(){
            while(!collide(board, current)) current.y++;
            current.y--;
            lockPiece();
        }
        
        function lockPiece(){
            merge(board, current);
            clearLines();
            spawn();
        }
        
        function spawn(){
            current = next || newPiece();
            next = newPiece();
            if(collide(board, current)){
                gameOver = true;
            }
            drawNext();
        }
        
        function move(dir){
            current.x += dir;
            if(collide(board, current)) current.x -= dir;
        }
        
        function softDrop(){
            current.y++;
            if(collide(board, current)){
                current.y--;
                lockPiece();
            }
        }
        
        function rotatePiece(dir){
            const pos = current.x;
            rotate(current.shape, dir);
            // simple wall kick: try offsets
            let offset = 1;
            while(collide(board, current)){
                current.x += offset;
                offset = -(offset + (offset>0?1:-1));
                if(Math.abs(offset) > current.shape[0].length) { 
                    rotate(current.shape, -dir); 
                    current.x = pos; 
                    return; 
                }
            }
        }
        
        function update(time=0){
            if(gameOver || paused){ draw(); return; }
            const delta = time - lastTime;
            lastTime = time;
            dropCounter += delta;
            if(dropCounter > dropInterval){
                current.y++;
                if(collide(board, current)){
                    current.y--;
                    lockPiece();
                }
                dropCounter = 0;
            }
            draw();
            requestAnimationFrame(update);
        }
        
        
        function updateUI() {
            document.getElementById('score').textContent = score.toLocaleString();
            document.getElementById('level').textContent = level;
            document.getElementById('lines').textContent = lines;
            
            // Update status based on level
            if (level > 5) {
                document.getElementById('connection').textContent = 'UNSTABLE';
                document.getElementById('connection').className = 'virus-text';
            }
            
            if (level % 10 === 0 && level > 0) {
                document.getElementById('firewall').textContent = 'BREACH';
                document.getElementById('firewall').className = 'virus-text';
            }
            
            const integrity = Math.max(50, 100 - level * 2);
            document.getElementById('integrity').textContent = integrity + '%';
            if (integrity < 70) {
                document.getElementById('integrity').className = 'virus-text';
            }
        }
        
        function handleKey(e){
            // Prevent page from scrolling when using arrows or space
            const k = e.key;
            if(k === 'ArrowLeft' || k === 'ArrowRight' || k === 'ArrowDown' || k === 'ArrowUp' || k === ' ' || k === 'Spacebar' || e.code === 'Space') {
                e.preventDefault();
            }
            if(gameOver && k.toLowerCase() !== 'r') return;
            
            switch(k){
                case 'ArrowLeft':
                case 'Left':
                    move(-1); break;
                case 'ArrowRight':
                case 'Right':
                    move(1); break;
                case 'ArrowDown':
                case 'Down':
                    softDrop(); break;
                case 'ArrowUp':
                case 'Up':
                    rotatePiece(1); break;
                case ' ':
                case 'Spacebar':
                case 'Space':
                    hardDrop(); break;
                case 'z': case 'Z': rotatePiece(-1); break;
                case 'x': case 'X': rotatePiece(1); break;
                case 'p': case 'P':
                    paused = !paused;
                    if(!paused){ lastTime = performance.now(); requestAnimationFrame(update); }
                    break;
                case 'r': case 'R':
                    reset(); break;
            }
        }
        
        function reset(){
            board = createMatrix(ROWS,COLS);
            bag = [];
            current = null; next = null;
            dropInterval = 800; lastTime = performance.now(); dropCounter = 0;
            score = 0; level = 1; lines = 0; gameOver = false; paused = false;
            spawn(); updateUI(); requestAnimationFrame(update);
        }
        
        function draw(){
            // clear
            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle = '#000008';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid lines
            ctx.strokeStyle = '#55ffff';
            ctx.lineWidth = 1;
            for (let x = 0; x <= COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK, 0);
                ctx.lineTo(x * BLOCK, ROWS * BLOCK);
                ctx.stroke();
            }
            for (let y = 0; y <= ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK);
                ctx.lineTo(COLS * BLOCK, y * BLOCK);
                ctx.stroke();
            }
            
            // board
            for(let y=0;y<ROWS;y++){
                for(let x=0;x<COLS;x++){
                    if(board[y][x]){
                        ctx.fillStyle = COLORS[board[y][x]] || '#999';
                        ctx.fillRect(x*BLOCK+1,y*BLOCK+1,BLOCK-2,BLOCK-2);
                        // subtle inner shine
                        ctx.fillStyle = 'rgba(255,255,255,0.08)';
                        ctx.fillRect(x*BLOCK+4,y*BLOCK+4,BLOCK-8,BLOCK-8);
                    }
                }
            }
            
            // current piece
            if(current){
                const m = current.shape;
                for(let y=0;y<m.length;y++){
                    for(let x=0;x<m[y].length;x++){
                        if(m[y][x]){
                            ctx.fillStyle = COLORS[current.id] || '#999';
                            const drawX = (current.x+x)*BLOCK;
                            const drawY = (current.y+y)*BLOCK;
                            ctx.fillRect(drawX+1, drawY+1, BLOCK-2, BLOCK-2);
                            // subtle inner shine
                            ctx.fillStyle = 'rgba(255,255,255,0.08)';
                            ctx.fillRect(drawX+4, drawY+4, BLOCK-8, BLOCK-8);
                        }
                    }
                }
            }
            
            // overlay game over / pause
            if(paused){
                ctx.fillStyle='rgba(7,8,11,0.6)';ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.fillStyle='#55ff55';ctx.font='24px Monaco';ctx.textAlign='center';
                ctx.fillText('SYSTEM PAUSED',canvas.width/2,canvas.height/2);
            }
            if(gameOver){
                ctx.fillStyle='rgba(2,6,12,0.8)';ctx.fillRect(0,0,canvas.width,canvas.height);
                ctx.fillStyle='#ff5555';ctx.font='26px Monaco';ctx.textAlign='center';
                ctx.fillText('SYSTEM BREACH',canvas.width/2,canvas.height/2 - 20);
                ctx.fillStyle='#55ffff';ctx.font='16px Monaco';
                ctx.fillText('FINAL SCORE: ' + score.toLocaleString(),canvas.width/2,canvas.height/2 + 10);
                ctx.fillText('PRESS R TO RESTORE',canvas.width/2,canvas.height/2 + 30);
            }
        }
        
        function drawNext(){
            nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
            const size = 18; const pad = 10;
            nextCtx.save();
            nextCtx.translate(10,10);
            const m = next.shape;
            for(let y=0;y<m.length;y++){
                for(let x=0;x<m[y].length;x++){
                    if(m[y][x]){
                        nextCtx.fillStyle = COLORS[next.id] || '#999';
                        nextCtx.fillRect(x*size, y*size, size-2, size-2);
                    }
                }
            }
            nextCtx.restore();
        }
        
        // Initialize game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            nextCanvas = document.getElementById('nextCanvas');
            nextCtx = nextCanvas.getContext('2d');
            canvas.width = COLS * BLOCK;
            canvas.height = ROWS * BLOCK;
            
            spawn(); 
            updateUI(); 
            requestAnimationFrame(update);
        }
        
        // Event listeners
        window.addEventListener('keydown', handleKey, false);
        window.addEventListener('load', init);
    </script>
</body>
</html>