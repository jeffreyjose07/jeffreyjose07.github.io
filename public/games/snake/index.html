<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Snake Game - Jeffrey Jose Portfolio</title>
<meta name="description" content="Classic Snake game with terminal aesthetic. Part of Jeffrey Jose's portfolio." />
<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
<style>
  :root {
    /* Light mode terminal colors */
    --terminal-green: #22c55e;
    --terminal-amber: #f59e0b;
    --terminal-cyan: #06b6d4;
    --terminal-magenta: #d946ef;
    --terminal-bg: #f8fafc;
    --terminal-gray: #475569;
    --terminal-dark-gray: #cbd5e1;
    --terminal-bright-green: #16a34a;
    --terminal-border: #e2e8f0;
  }

  /* Dark mode terminal colors */
  html.dark {
    --terminal-green: #55ff55;
    --terminal-amber: #ff8855;
    --terminal-cyan: #55ffff;
    --terminal-magenta: #ff55ff;
    --terminal-bg: #000000;
    --terminal-gray: #c9c9c9;
    --terminal-dark-gray: #333333;
    --terminal-bright-green: #00ff00;
    --terminal-border: #55ff55;
  }
  
  * { 
    box-sizing: border-box; 
    margin: 0;
    padding: 0;
  }
  
  body {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: var(--terminal-bg);
    color: var(--terminal-gray);
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 14px;
    line-height: 1.4;
    padding: 80px 20px 20px 20px; /* Top padding for portfolio navbar */
    overflow-x: hidden;
  }
  
  .header {
    text-align: center;
    margin-bottom: 20px;
    border: 1px solid var(--terminal-border);
    padding: 10px 20px;
    background: rgba(34, 197, 94, 0.1);
  }

  html.dark .header {
    background: rgba(85, 255, 85, 0.1);
  }
  
  .header h1 {
    color: var(--terminal-green);
    font-size: 24px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 2px;
    margin-bottom: 5px;
  }
  
  .header .subtitle {
    color: var(--terminal-cyan);
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  
  .game-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    width: 100%;
    max-width: 800px;
    align-items: center;
  }
  
  .hud {
    background: rgba(34, 197, 94, 0.05);
    border: 1px solid var(--terminal-border);
    padding: 10px;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 15px;
    width: 100%;
  }

  html.dark .hud {
    background: rgba(85, 255, 85, 0.05);
  }
  
  .hud .stat {
    text-align: center;
    padding: 5px;
  }
  
  .hud .label {
    color: var(--terminal-gray);
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  
  .hud .value {
    color: var(--terminal-green);
    font-weight: bold;
    font-size: 18px;
  }
  
  .controls {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 10px;
    width: 100%;
    margin-bottom: 10px;
  }
  
  .controls select, .controls button {
    background: var(--terminal-bg);
    color: var(--terminal-green);
    border: 1px solid var(--terminal-border);
    padding: 8px;
    font-family: inherit;
    font-size: 12px;
    cursor: pointer;
  }
  
  .controls select:hover, .controls button:hover {
    background: rgba(34, 197, 94, 0.1);
  }

  html.dark .controls select:hover, 
  html.dark .controls button:hover {
    background: rgba(85, 255, 85, 0.1);
  }
  
  .controls select option {
    background: var(--terminal-bg);
    color: var(--terminal-green);
  }
  
  canvas {
    width: 100%;
    max-width: 768px;
    height: auto;
    image-rendering: pixelated;
    background: var(--terminal-bg);
    border: 2px solid var(--terminal-border);
    box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
  }

  html.dark canvas {
    box-shadow: 0 0 20px rgba(85, 255, 85, 0.3);
  }
  
  .instructions {
    text-align: center;
    font-size: 12px;
    color: var(--terminal-gray);
    margin-top: 15px;
    padding: 15px;
    border: 1px solid var(--terminal-dark-gray);
    background: rgba(34, 197, 94, 0.03);
  }

  html.dark .instructions {
    background: rgba(85, 255, 85, 0.03);
  }
  
  .key {
    color: var(--terminal-cyan);
    font-weight: bold;
    padding: 2px 4px;
    border: 1px solid var(--terminal-dark-gray);
    margin: 0 2px;
  }
  
  .overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 10;
  }
  
  .banner {
    background: rgba(248, 250, 252, 0.95);
    border: 2px solid var(--terminal-border);
    padding: 20px 30px;
    text-align: center;
  }

  html.dark .banner {
    background: rgba(0, 0, 0, 0.9);
  }
  
  .banner h2 {
    color: var(--terminal-green);
    font-size: 20px;
    margin-bottom: 10px;
    text-transform: uppercase;
    letter-spacing: 2px;
  }
  
  .banner .subtitle {
    color: var(--terminal-cyan);
    font-size: 12px;
  }
  
  .overlay[hidden] {
    display: none !important;
  }

  /* Mobile Touch Controls */
  .touch-controls {
    display: none;
    margin-top: 20px;
    gap: 30px;
    align-items: center;
    justify-content: center;
  }

  .touch-dpad {
    display: grid;
    grid-template-areas: 
      ". up ."
      "left . right"
      ". down .";
    grid-template-columns: 50px 50px 50px;
    grid-template-rows: 50px 50px 50px;
    gap: 5px;
  }

  .touch-btn {
    background: var(--terminal-bg);
    border: 1px solid var(--terminal-border);
    color: var(--terminal-green);
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: inherit;
  }

  .touch-btn:active {
    background: rgba(34, 197, 94, 0.2);
    color: var(--terminal-bright-green);
  }

  html.dark .touch-btn:active {
    background: rgba(85, 255, 85, 0.2);
  }

  .touch-up { grid-area: up; }
  .touch-down { grid-area: down; }
  .touch-left { grid-area: left; }
  .touch-right { grid-area: right; }

  .touch-actions {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .touch-action {
    background: var(--terminal-bg);
    border: 1px solid var(--terminal-border);
    color: var(--terminal-green);
    font-size: 20px;
    width: 50px;
    height: 50px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: inherit;
  }

  .touch-action:active {
    background: rgba(34, 197, 94, 0.2);
    color: var(--terminal-bright-green);
  }

  html.dark .touch-action:active {
    background: rgba(85, 255, 85, 0.2);
  }

  @media (max-width: 768px) {
    body {
      padding: 10px;
      justify-content: flex-start;
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100vh;
    }

    .game-container {
      margin-top: 0;
      width: 100%;
    }

    .header {
      margin-bottom: 10px;
    }

    .header h1 {
      font-size: 18px;
    }

    .hud {
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      padding: 8px;
    }

    .controls {
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }

    .touch-controls {
      display: flex;
    }

    .instructions {
      display: none;
    }
  }

</style>
</head>
<body>
  <div class="header">
    <h1>Snake Game</h1>
    <div class="subtitle">Terminal Edition</div>
  </div>

  <div class="game-container">
    <div class="hud">
      <div class="stat">
        <div class="label">Score</div>
        <div id="score" class="value">0</div>
      </div>
      <div class="stat">
        <div class="label">High Score</div>
        <div id="high" class="value">0</div>
      </div>
      <div class="stat">
        <div class="label">Speed</div>
        <select id="speed">
          <option value="6">Slow (6)</option>
          <option value="8" selected>Normal (8)</option>
          <option value="12">Fast (12)</option>
          <option value="16">Very Fast (16)</option>
          <option value="24">Insane (24)</option>
        </select>
      </div>
      <div class="stat">
        <div class="label">Mode</div>
        <select id="mode">
          <option value="walls" selected>Walls</option>
          <option value="wrap">Wrap</option>
        </select>
      </div>
    </div>

    <div class="controls">
      <button id="btnStart">Start</button>
      <button id="btnPause">Pause</button>
      <button id="btnRestart">Restart</button>
    </div>

    <div style="position: relative; width: 100%;">
      <canvas id="game" width="768" height="576"></canvas>
      <div class="overlay" id="overlay" hidden>
        <div class="banner" id="banner">
          <h2 id="bannerTitle"></h2>
          <div id="bannerSub" class="subtitle"></div>
        </div>
      </div>
    </div>

    <!-- Mobile Touch Controls -->
    <div class="touch-controls" id="touchControls">
      <div class="touch-dpad">
        <button class="touch-btn touch-up" id="touchUp">‚Üë</button>
        <div class="touch-middle">
          <button class="touch-btn touch-left" id="touchLeft">‚Üê</button>
          <button class="touch-btn touch-right" id="touchRight">‚Üí</button>
        </div>
        <button class="touch-btn touch-down" id="touchDown">‚Üì</button>
      </div>
      <div class="touch-actions">
        <button class="touch-action" id="touchPause">‚è∏</button>
        <button class="touch-action" id="touchRestart">üîÑ</button>
      </div>
    </div>

    <div class="instructions">
      <strong>CONTROLS:</strong>
      <span class="key">‚Üë</span> <span class="key">‚Üì</span> <span class="key">‚Üê</span> <span class="key">‚Üí</span>
      or <span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span><br>
      <strong>PAUSE:</strong> <span class="key">Space</span> ‚Ä¢
      <strong>RESTART:</strong> <span class="key">R</span><br>
      Swipe canvas or use touch controls below
    </div>
  </div>

<script>
(() => {
  'use strict';

  const CELL = 24;
  const COLS = 32;
  const ROWS = 24;
  const START_LEN = 4;

  // Terminal colors
  const COLORS = {
    snakeHead: '#00ff00',    // Bright green head
    snakeBody: '#55ff55',    // Terminal green body
    snakeBody2: '#44dd44',   // Slightly darker alternating
    food: '#ff8855',         // Terminal amber
    grid: '#333333',         // Dark gray grid
    bg: '#000000',           // Black background
    danger: '#ff5555'        // Red for death
  };

  // DOM elements - secure references
  const elements = {
    canvas: document.getElementById("game"),
    score: document.getElementById("score"),
    high: document.getElementById("high"),
    speed: document.getElementById("speed"),
    mode: document.getElementById("mode"),
    btnStart: document.getElementById("btnStart"),
    btnPause: document.getElementById("btnPause"),
    btnRestart: document.getElementById("btnRestart"),
    overlay: document.getElementById("overlay"),
    bannerTitle: document.getElementById("bannerTitle"),
    bannerSub: document.getElementById("bannerSub")
  };

  // Validate DOM elements exist
  for (const [key, element] of Object.entries(elements)) {
    if (!element) {
      console.error(`Critical element missing: ${key}`);
      return;
    }
  }

  const ctx = elements.canvas.getContext("2d");
  if (!ctx) {
    console.error("Canvas context not available");
    return;
  }

  // Game state
  const gameState = {
    status: 'idle', // 'idle' | 'running' | 'paused' | 'gameover'
    wrapMode: false,
    speed: 8,
    stepMs: 1000 / 8, // Initial speed
    score: 0,
    high: parseInt(localStorage.getItem("snake.high") || "0", 10),
    snake: [],
    dir: { x: 1, y: 0 },
    nextDir: { x: 1, y: 0 },
    food: { x: 0, y: 0 },
    touchStart: null,
    last: 0,
    acc: 0,
    rafId: null
  };

  // Initialize high score display
  elements.high.textContent = gameState.high.toString();

  // Secure random number generation
  function secureRandom(min, max) {
    const range = max - min + 1;
    const array = new Uint32Array(1);
    crypto.getRandomValues(array);
    return Math.floor((array[0] / (0xFFFFFFFF + 1)) * range) + min;
  }

  // UI functions
  function hideOverlay() {
    elements.overlay.hidden = true;
    elements.bannerTitle.textContent = "";
    elements.bannerSub.textContent = "";
  }

  function showOverlay(title, subtitle) {
    elements.bannerTitle.textContent = title;
    elements.bannerSub.textContent = subtitle;
    elements.overlay.hidden = false;
  }

  function updateOverlay() {
    if (gameState.status === 'idle') {
      showOverlay("SNAKE", "Press Start to Play");
    } else if (gameState.status === 'paused') {
      showOverlay("PAUSED", "Press Space to Resume");
    } else if (gameState.status === 'gameover') {
      showOverlay("GAME OVER", `Score: ${gameState.score}`);
    } else {
      hideOverlay();
    }
  }

  function updateScore() {
    elements.score.textContent = gameState.score;
    if (gameState.score > gameState.high) {
      gameState.high = gameState.score;
      elements.high.textContent = gameState.high;
      localStorage.setItem("snake.high", gameState.high);
    }
  }

  // Game Logic
  function initGame() {
    gameState.snake = [];
    const startX = Math.floor(COLS / 2);
    const startY = Math.floor(ROWS / 2);
    for (let i = 0; i < START_LEN; i++) {
      gameState.snake.push({ x: startX - i, y: startY });
    }
    gameState.dir = { x: 1, y: 0 };
    gameState.nextDir = { x: 1, y: 0 };
    gameState.score = 0;
    updateScore();
    placeFood();
    gameState.status = 'idle';
    updateOverlay();
    draw();
  }

  function placeFood() {
    let valid = false;
    while (!valid) {
      const x = secureRandom(0, COLS - 1);
      const y = secureRandom(0, ROWS - 1);
      // Check collision with snake
      let collision = false;
      for (const segment of gameState.snake) {
        if (segment.x === x && segment.y === y) {
          collision = true;
          break;
        }
      }
      if (!collision) {
        gameState.food = { x, y };
        valid = true;
      }
    }
  }

  function step() {
    gameState.dir = gameState.nextDir;
    const head = gameState.snake[0];
    let nextX = head.x + gameState.dir.x;
    let nextY = head.y + gameState.dir.y;

    // Wrap or Wall collision
    if (gameState.wrapMode) {
      if (nextX < 0) nextX = COLS - 1;
      if (nextX >= COLS) nextX = 0;
      if (nextY < 0) nextY = ROWS - 1;
      if (nextY >= ROWS) nextY = 0;
    } else {
      if (nextX < 0 || nextX >= COLS || nextY < 0 || nextY >= ROWS) {
        gameOver();
        return;
      }
    }

    // Self collision
    for (const segment of gameState.snake) {
      if (nextX === segment.x && nextY === segment.y) {
        gameOver();
        return;
      }
    }

    // Move snake
    const newHead = { x: nextX, y: nextY };
    gameState.snake.unshift(newHead);

    // Eat food
    if (nextX === gameState.food.x && nextY === gameState.food.y) {
      gameState.score += 10;
      updateScore();
      placeFood();
    } else {
      gameState.snake.pop();
    }
  }

  function draw() {
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, elements.canvas.width, elements.canvas.height);

    // Draw grid
    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth = 1;
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath();
      ctx.moveTo(x * CELL, 0);
      ctx.lineTo(x * CELL, ROWS * CELL);
      ctx.stroke();
    }
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * CELL);
      ctx.lineTo(COLS * CELL, y * CELL);
      ctx.stroke();
    }

    // Draw food with glow effect
    drawCell(gameState.food.x, gameState.food.y, COLORS.food, true);

    // Draw snake
    gameState.snake.forEach((segment, index) => {
      if (index === 0) {
        const color = gameState.status === 'gameover' ? COLORS.danger : COLORS.snakeHead;
        drawCell(segment.x, segment.y, color);
        
        // Draw eye
        if (gameState.status !== 'gameover') {
          const eyeX = segment.x * CELL + (gameState.dir.x >= 0 ? CELL - 6 : 6);
          const eyeY = segment.y * CELL + (gameState.dir.y >= 0 ? CELL - 6 : 6);
          ctx.fillStyle = "#000000";
          ctx.beginPath();
          ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
          ctx.fill();
        }
      } else {
        const color = index % 2 ? COLORS.snakeBody : COLORS.snakeBody2;
        drawCell(segment.x, segment.y, color);
      }
    });
  }

  function drawCell(gridX, gridY, color, glow = false) {
    const x = gridX * CELL + 2;
    const y = gridY * CELL + 2;
    const size = CELL - 4;

    ctx.fillStyle = color;
    ctx.fillRect(x, y, size, size);

    if (glow) {
      ctx.shadowColor = color;
      ctx.shadowBlur = 10;
      ctx.fillRect(x, y, size, size);
      ctx.shadowBlur = 0;
    }
  }

  function handleKeydown(e) {
    if (e.key === " " || e.key === "Spacebar") {
      e.preventDefault();
      pauseToggle();
    } else if (e.key === "r" || e.key === "R") {
      e.preventDefault();
      startGame();
    } else if (gameState.status === 'running') {
      const key = e.key.toLowerCase();
      if (key === "arrowup" || key === "w") {
        e.preventDefault();
        queueTurn(0, -1);
      } else if (key === "arrowdown" || key === "s") {
        e.preventDefault();
        queueTurn(0, 1);
      } else if (key === "arrowleft" || key === "a") {
        e.preventDefault();
        queueTurn(-1, 0);
      } else if (key === "arrowright" || key === "d") {
        e.preventDefault();
        queueTurn(1, 0);
      }
    } else if (gameState.status === 'idle' && (e.key === "Enter" || e.key === " ")) {
      e.preventDefault();
      startGame();
    }
  }

  function handleTouchStart(e) {
    if (e.touches.length > 0) {
      const touch = e.touches[0];
      gameState.touchStart = { x: touch.clientX, y: touch.clientY };
    }
  }

  function handleTouchMove(e) {
    if (!gameState.touchStart || e.touches.length === 0) return;
    
    const touch = e.touches[0];
    const deltaX = touch.clientX - gameState.touchStart.x;
    const deltaY = touch.clientY - gameState.touchStart.y;
    const minSwipeDistance = 30;

    if (Math.abs(deltaX) > minSwipeDistance || Math.abs(deltaY) > minSwipeDistance) {
      if (gameState.status === 'idle') startGame();
      if (gameState.status !== 'running') return;

      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        queueTurn(deltaX > 0 ? 1 : -1, 0);
      } else {
        queueTurn(0, deltaY > 0 ? 1 : -1);
      }
      gameState.touchStart = null;
    }
  }

  function queueTurn(x, y) {
    const current = gameState.dir;
    if ((current.x === 0 && x === 0) || (current.y === 0 && y === 0)) return;
    if (current.x === -x || current.y === -y) return;
    gameState.nextDir = { x, y };
  }

  function startGame() {
    if (gameState.rafId) {
      cancelAnimationFrame(gameState.rafId);
    }
    initGame();
    gameState.status = 'running';
    updateOverlay();
    gameState.last = performance.now();
    gameState.acc = 0;
    gameLoop();
  }

  function pauseToggle() {
    if (gameState.status === 'running') {
      gameState.status = 'paused';
      if (gameState.rafId) {
        cancelAnimationFrame(gameState.rafId);
        gameState.rafId = null;
      }
    } else if (gameState.status === 'paused') {
      gameState.status = 'running';
      gameState.last = performance.now();
      gameLoop();
    }
    updateOverlay();
  }

  function gameOver() {
    gameState.status = 'gameover';
    if (gameState.rafId) {
      cancelAnimationFrame(gameState.rafId);
      gameState.rafId = null;
    }
    updateOverlay();
    draw();
  }

  function resetGame() {
    if (gameState.rafId) {
      cancelAnimationFrame(gameState.rafId);
      gameState.rafId = null;
    }
    initGame();
  }

  function updateSpeed(speed) {
    gameState.speed = parseInt(speed, 10);
    gameState.stepMs = 1000 / gameState.speed;
  }

  function setWrapMode(wrap) {
    gameState.wrapMode = wrap;
  }

  function gameLoop() {
    const now = performance.now();
    const dt = now - gameState.last;
    gameState.last = now;
    gameState.acc += dt;

    if (gameState.acc >= gameState.stepMs) {
      gameState.acc -= gameState.stepMs;
      step();
    }

    draw();

    if (gameState.status === 'running') {
      gameState.rafId = requestAnimationFrame(gameLoop);
    }
  }

  // Event listeners
  document.addEventListener("keydown", handleKeydown);
  elements.canvas.addEventListener("touchstart", handleTouchStart, {passive: true});
  elements.canvas.addEventListener("touchmove", handleTouchMove, {passive: true});

  elements.btnStart.addEventListener("click", startGame);
  elements.btnPause.addEventListener("click", pauseToggle);
  elements.btnRestart.addEventListener("click", startGame);

  // Touch control event listeners
  const touchUp = document.getElementById("touchUp");
  const touchDown = document.getElementById("touchDown");
  const touchLeft = document.getElementById("touchLeft");
  const touchRight = document.getElementById("touchRight");
  const touchPause = document.getElementById("touchPause");
  const touchRestart = document.getElementById("touchRestart");

  function ensureRunning() {
    if (gameState.status === 'idle') startGame();
  }

  // Better touch handling - use touchend for more responsive feel
  function addTouchHandler(element, handler) {
    if (!element) return;

    element.addEventListener("click", handler);
    element.addEventListener("touchend", (e) => {
      e.preventDefault();
      handler();
    }, {passive: false});
    element.addEventListener("touchstart", (e) => e.preventDefault(), {passive: false});
  }

  addTouchHandler(touchUp, () => { ensureRunning(); queueTurn(0, -1); });
  addTouchHandler(touchDown, () => { ensureRunning(); queueTurn(0, 1); });
  addTouchHandler(touchLeft, () => { ensureRunning(); queueTurn(-1, 0); });
  addTouchHandler(touchRight, () => { ensureRunning(); queueTurn(1, 0); });
  addTouchHandler(touchPause, pauseToggle);
  addTouchHandler(touchRestart, startGame);

  elements.speed.addEventListener("change", (e) => {
    updateSpeed(e.target.value);
  });

  elements.mode.addEventListener("change", (e) => {
    setWrapMode(e.target.value === "wrap");
  });

  // Detect mobile devices and show touch controls
  function detectMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
           (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  }

  if (detectMobile()) {
    const touchControls = document.getElementById('touchControls');
    if (touchControls) {
      touchControls.style.display = 'flex';
    }
  }

  // Initialize game
  updateSpeed(elements.speed.value);
  setWrapMode(elements.mode.value === "wrap");
  resetGame();
})();
</script>
</body>
</html>